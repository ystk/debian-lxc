From 3c62cae308e8e66dcc616c5bd34671e1d2eea5a6 Mon Sep 17 00:00:00 2001
From: Serge Hallyn <serge.hallyn@ubuntu.com>
Date: Mon, 31 Aug 2015 12:57:20 -0500
Subject: [PATCH 1/1] Protect container mounts against symlinks

When a container starts up, lxc sets up the container's inital fstree
by doing a bunch of mounting, guided by the container configuration
file.  The container config is owned by the admin or user on the host,
so we do not try to guard against bad entries.  However, since the
mount target is in the container, it's possible that the container admin
could divert the mount with symbolic links.  This could bypass proper
container startup (i.e. confinement of a root-owned container by the
restrictive apparmor policy, by diverting the required write to
/proc/self/attr/current), or bypass the (path-based) apparmor policy
by diverting, say, /proc to /mnt in the container.

To prevent this,

1. do not allow mounts to paths containing symbolic links

2. do not allow bind mounts from relative paths containing symbolic
links.

Details:

This patch causes lxc to check /proc/self/mountinfo after each
mount into a container rootfs (that is, where we are not chrooted
into the container), making sure that the mount target wasn't a
symlink.

Use safe_mount() in mount_file_entries(), when mounting container proc,
and when needed.  In particular, safe_mount() need not be used in
any case where:

1. the mount is done in the container's namespace
2. the mount is for the container's rootfs
3. the mount is relative to a tmpfs or proc/sysfs which we have
   just safe_mount()ed ourselves

Since we were using proc/net as a temporary placeholder for /proc/sys/net
during container startup, and proc/net is a symbolic link, use proc/tty
instead.

Update the lxc.container.conf manpage with details about the new
restrictions.

Finally, add a testcase to test some symbolic link possibilities.

lxc-test-symlink: background lxc-start

CVE-2015-1335

Notes on the 0.7.x backport (for Debian squeeze-lts)

 * Debian squeeze ships Linux 2.6.32 which lacks O_PATH flaf support in
   openat(). Thus, for the safe_mount implementation we use an approach
   that got also used in lxc for Ubuntu trusty: do bind mount and afterwards
   check if it was mounted onto a symlink. If so, immediately unmount again.
 * LXC 0.7.x does not have a test suite, so the test case was omitted.

Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
Backported to 0.7.x: Mike Gabriel <mike.gabriel@das-netzwerkteam.de>
---
 doc/lxc.conf.sgml.in |  12 +++
 src/lxc/conf.c                 |  34 +++---
 src/lxc/utils.c                | 233 +++++++++++++++++++++++++++++++++++++++++
 src/lxc/utils.h                |   3 +
 src/tests/Makefile.am          |   3 +-
 src/tests/lxc-test-symlink     |  88 ++++++++++++++++
 8 files changed, 362 insertions(+), 20 deletions(-)
 create mode 100644 src/tests/lxc-test-symlink

--- a/doc/lxc.conf.sgml.in
+++ b/doc/lxc.conf.sgml.in
@@ -483,6 +483,18 @@
 	The capabilities can be dropped in the container if this one
 	is run as root.
       </para>
+      <para>
+       NOTE - LXC will generally ensure that mount targets and relative
+       bind-mount sources are properly confined under the container
+       root, to avoid attacks involving over-mounting host directories
+       and files.  (Symbolic links in absolute mount sources are ignored)
+       However, if the container configuration first mounts a directory which
+       is under the control of the container user, such as /home/joe, into
+        the container at some <filename>path</filename>, and then mounts
+        under <filename>path</filename>, then a TOCTTOU attack would be
+        possible where the container user modifies a symbolic link under
+        his home directory at just the right time.
+      </para>
       <variablelist>
 	<varlistentry>
 	  <term>
--- a/src/lxc/conf.c
+++ b/src/lxc/conf.c
@@ -396,7 +396,8 @@
 		 * to check the file is present or not because it fails
 		 * with EACCES errno and I don't know why :( */
 
-		if (mount(pty_info->name, path, "none", MS_BIND, 0)) {
+		if (safe_mount(pty_info->name, path, "none", MS_BIND, 0,
+			       rootfs->mount)) {
 			WARN("failed to mount '%s'->'%s'",
 			     pty_info->name, path);
 			continue;
@@ -688,7 +689,7 @@
 		return -1;
 	}
 
-	if (mount(console->name, path, "none", MS_BIND, 0)) {
+	if (safe_mount(console->name, path, "none", MS_BIND, 0, rootfs->mount)) {
 		ERROR("failed to mount '%s' on '%s'", console->name, path);
 		return -1;
 	}
@@ -781,7 +782,7 @@
 	return 0;
 }
 
-static int mount_file_entries(FILE *file)
+static int mount_file_entries(FILE *file, const char *rootfs)
 {
 	struct mntent *mntent;
 	int ret = -1;
@@ -798,8 +799,8 @@
 			goto out;
 		}
 
-		if (mount(mntent->mnt_fsname, mntent->mnt_dir,
-			  mntent->mnt_type, mntflags & ~MS_REMOUNT, mntdata)) {
+		if (safe_mount(mntent->mnt_fsname, mntent->mnt_dir,
+			  mntent->mnt_type, mntflags & ~MS_REMOUNT, mntdata, rootfs)) {
 			SYSERROR("failed to mount '%s' on '%s'",
 					 mntent->mnt_fsname, mntent->mnt_dir);
 			goto out;
@@ -812,9 +813,9 @@
 			       "or remount options",
 			       mntent->mnt_fsname, mntent->mnt_dir);
 
-			if (mount(mntent->mnt_fsname, mntent->mnt_dir,
+			if (safe_mount(mntent->mnt_fsname, mntent->mnt_dir,
 				  mntent->mnt_type,
-				  mntflags | MS_REMOUNT, mntdata)) {
+				  mntflags | MS_REMOUNT, mntdata, rootfs)) {
 				SYSERROR("failed to mount '%s' on '%s'",
 					 mntent->mnt_fsname, mntent->mnt_dir);
 				goto out;
@@ -834,7 +835,8 @@
 	return ret;
 }
 
-static int setup_mount(const char *fstab)
+static int setup_mount(const struct lxc_rootfs *rootfs,
+		       const char *fstab)
 {
 	FILE *file;
 	int ret;
@@ -848,13 +850,14 @@
 		return -1;
 	}
 
-	ret = mount_file_entries(file);
+	ret = mount_file_entries(file, rootfs->mount);
 
 	endmntent(file);
 	return ret;
 }
 
-static int setup_mount_entries(struct lxc_list *mount)
+static int setup_mount_entries(const struct lxc_rootfs *rootfs,
+			       struct lxc_list *mount)
 {
 	FILE *file;
 	struct lxc_list *iterator;
@@ -874,7 +877,7 @@
 
 	rewind(file);
 
-	ret = mount_file_entries(file);
+	ret = mount_file_entries(file, rootfs->mount);
 
 	fclose(file);
 	return ret;
@@ -1445,12 +1448,12 @@
 		return -1;
 	}
 
-	if (setup_mount(lxc_conf->fstab)) {
+	if (setup_mount(&lxc_conf->rootfs, lxc_conf->fstab)) {
 		ERROR("failed to setup the mounts for '%s'", name);
 		return -1;
 	}
 
-	if (setup_mount_entries(&lxc_conf->mount_list)) {
+	if (setup_mount_entries(&lxc_conf->rootfs, &lxc_conf->mount_list)) {
 		ERROR("failed to setup the mount entries for '%s'", name);
 		return -1;
 	}
--- a/src/lxc/utils.c
+++ b/src/lxc/utils.c
@@ -26,6 +26,7 @@
 #include <unistd.h>
 #include <stdlib.h>
 #include <stddef.h>
+#include <stdbool.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/mman.h>
@@ -116,7 +117,7 @@
 	if (umount(target))
 		WARN("failed to unmount %s : %s", target, strerror(errno));
 
-	if (mount(source, target, type, 0, NULL)) {
+	if (safe_mount(source, target, type, 0, NULL, "/")) {
 		ERROR("failed to mount %s : %s", target, strerror(errno));
 		return -1;
 	}
@@ -191,3 +192,93 @@
 
         return 0;
 }
+
+/*
+ * ws points into an array of \0-separate path elements.
+ * ws should be pointing to one of the path elements or
+ * the next \0.  It will return the first character of the
+ * next path element.
+ */
+static char *next_word(char *ws) {
+	while (*ws && *ws != ' ') ws++;
+	while (*ws && *ws == ' ') ws++;
+	return ws;
+}
+
+/*
+ * This is only used during container startup.  So we know we won't race
+ * with anyone else mounting.  Check the last line in /proc/self/mountinfo
+ * to make sure the target is under the container root.
+ */
+static bool ensure_not_symlink(const char *target, const char *croot)
+{
+	FILE *f = fopen("/proc/self/mountinfo", "r");
+	char *line = NULL, *ws = NULL, *we = NULL;
+	size_t len = 0, i;
+	bool ret = false;
+
+	if (!croot || croot[0] == '\0')
+		return true;
+
+	if (!f) {
+		ERROR("Cannot open /proc/self/mountinfo");
+		return false;
+	}
+
+	while (getline(&line, &len, f) != -1) {
+	}
+	fclose(f);
+
+	if (!line)
+		return false;
+	ws = line;
+	for (i = 0; i < 4; i++)
+		ws = next_word(ws);
+	if (!*ws)
+		goto out;
+	we = ws;
+	while (*we && *we != ' ')
+		we++;
+	if (!*we)
+		goto out;
+	*we = '\0';
+
+	/* now make sure that ws starts with croot and ends with rest of target */
+	if (croot && strncmp(ws, croot, strlen(croot)) != 0) {
+		ERROR("Mount onto %s resulted in %s\n", target, ws);
+		goto out;
+	}
+
+	size_t start = croot ? strlen(croot) : 0;
+	if (strcmp(ws + start, target + start) != 0) {
+		ERROR("Mount onto %s resulted in %s\n", target, ws);
+		goto out;
+	}
+
+	ret = true;
+
+out:
+	free(line);
+	return ret;
+}
+/*
+ * Safely mount a path into a container, ensuring that the mount target
+ * is under the container's @rootfs.  (If @rootfs is NULL, then the container
+ * uses the host's /)
+ */
+int safe_mount(const char *src, const char *dest, const char *fstype,
+	       unsigned long flags, const void *data, const char *rootfs)
+{
+	int ret;
+	ret = mount(src, dest, fstype, flags, data);
+	if (ret < 0) {
+		SYSERROR("Mount of '%s' onto '%s' failed", src, dest);
+		return ret;
+	}
+	if (!ensure_not_symlink(dest, rootfs)) {
+		ERROR("Mount of '%s' onto '%s' was onto a symlink!", src, dest);
+		umount(dest);
+		return -1;
+	}
+	return 0;
+}
--- a/src/lxc/utils.h
+++ b/src/lxc/utils.h
@@ -54,3 +54,6 @@
 extern int lxc_setup_fs(void);
 extern int get_u16(ushort *val, const char *arg, int base);
 extern int mkdir_p(const char *dir, mode_t mode);
+
+int safe_mount(const char *src, const char *dest, const char *fstype,
+               unsigned long flags, const void *data, const char *rootfs);
